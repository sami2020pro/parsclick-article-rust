در بخش بعدی مقاله راست میخواهیم با `راست` بیشتر آشنا بشیم.

![مقاله ی آموزشی زبان راست در پارس کلیک](https://images.pexels.com/photos/3768894/pexels-photo-3768894.jpeg?auto=compress&cs=tinysrgb&dpr=3&h=750&w=1260)

در این مقاله میخواهیم با `comments` و `variables` و `formatted print` در زبان راست آشنا بشیم و تمرین هایی رو انجام بدیم.

### نظر گذاری یا comment

برنامه نویس های مبتدی یک سوالی میپرسن مبنا بر اینکه چرا باید **نظر گذاری** یا به عبارت دیگه **کامنت گذاری** کنیم ؟
در جواب باید بگیم که میتوونیم براساس تجربیاتمون بگیم دو دلیل مهم داریم:

> یک: خیلی ها که با زبان برنامه نویسی ما آشنا نیستن میتونن با خووندن کامنت ها کاری که برنامه انجام میده رو متوجه بشن

> دو: بعضی از کد های ما ممکن هست بسیار پیچیده بشن کامنت گذاری باعث میشه که این مشکل برطرف بشه تا حدودی

حالا ما در راست میتوانیم به سه روش عمده کامنت گذاری کنیم یا همان نظر گذاری.

به کد زیر توجه کنید

```rust
fn main() {
       // The first method

       /*
        * The second method
        */

       /* The third method */
       println!("Hello World")
}
```

حالا اگه کدمون رو کامپایل کنیم و اجرا کنیم نتیجه برنامه ما بدون اررور و وارنینگ خواهد بود به صورت زیر

```
Hello World
```

### متغیر یا variable

متغیر ها بصورت کلی میتوونن مقداری رو توی خودشون نگه دارن و ما از متغیر ها به صورت گسترده ای استفاده می کنیم؛
هر متغیر در زبان های برنامه نویسی می تواند یک **نوع** یا چند **نوع** از داده رو توی خودشون ذخیره کنن.

در زبان راست برای درست کردن یک متغیر ساده از کلیدواژه `let` استفاده می کنیم مشابه استاندارد های `ES`.

به کد زیر توجه کنید این کد از `format` کردن استفاده کرده که جلوتر بیشتر باهاش آشنا میشیم

```rust
fn main() {
        let my_age: i32  = 14;
        let my_birthday: i32 = 2007;

        println!("Age: {} | birthday: {}", my_age, my_birthday);
}
```

به خروجی کد هم توجه کنید

```
Age: 14 | birthday: 2007
```

چند نکته **خیلی مهم** وجود داره توی زبان راست که باید بهشون توجه کنید.

هرگز از روش `camelCase` برای نام گذاری متغیر هاتون استفاده نکنید تا در زمان کامپایل کردن کد مشکلی نداشته باشید.

برای نام گذاری متغیر های چند کلمه ای و ... از روش `snake_case` استفاده کنید.

وقتی کد شما بیشتر از یک خط میشه باید از `سمی کالن` یا به عبارت دیگه از علامت `;` استفاده کنید.

اگه متغیری رو درست کردید که نمی خواید استفاده کنید یا به صورت تست ساختید اون متغیر رو حتما قبلش `_` بزارید تا به کامپایلر اطلاع بدید که نمی خواید از اون متغیر استفاده کنید به طور مثال این `_variable` متغیر.

هرگز دو متغیر رو یا بیشتر که **نوعشون** متفاوته با هم دیگه `format` نکنید چون در زمان کامپایل به مشکل بر می خورید.

زبان راست دو نوع `تایپ سیستم` یا به عبارت دیگه `type system` داره به نام `static` و `inferred` در تایپ سیستم استاتیک شما نیاز دارید که **نوع** متغیر رو مشخص کنید ولی در تایپ سیستم اینفررد شما نیاز ندارید که نوع متغیر رو مشخص کنید و خود کامپایلر به صورت هوشمند **نوع** متغیر رو تشخیص میده البته این رو هم بگیم که در راست فقط همین تایپ سیستم ها وجود نداره و بیشتر هست.

حالا میخوام یک **نکته** مهم رو بهتون بگم، در زبان راست شما باید از روش `snake_case` برای نام گذاری متغیر ها، تابع ها، متد ها، ماژول ها و ماکرو ها استفاده کنید که باز نکاتی دارند که در مقاله های بعدی و جلوتر به آن ها می پردازیم؛ میتونید خودتون هم این موضوع رو امتحان کنید.

حالا میخواهیم دو `تایپ سیستم` گفته شده رو بررسی کنیم.

تایپ سیستم استاتیک

```rust
fn main() {
	let _variable: i32 = 2007
}
```

تایپ سیستم اینفررد

```rust
fn main() {
	let _variable = 2007
}
```

هر دو تایپ سیستم کاربرد دارند و نمیشه گفت اینفررد بهتره یا استاتیک بهتره و هر دو کد کامپایل و اجرا میشن بدون هیچ مشکلی و اگه هم **گولنگ** یا **تایپ اسکریپت** کار کرده باشید از قبل با این موضوع آشنا هستید.

یه نکته ی دیگه هم هست که باید بگیم؛  **inferred** به صورت `inference` هم شناخته میشه؛ اگه میخواید در رابطه با این دو تا تایپ سیستم اطلاعات بیشتری کسب کنید به صفحات زیر مراجعه کنید.

[Type inference](https://en.wikipedia.org/wiki/Type_inference)

[Type static](https://en.wikipedia.org/wiki/Type_system#STATIC)

### فرمتد پرینت یا formatted print

به کد زیر توجه کنید (در اینجا برای از بین بردن گیج شدن کاربر از نظر گذاری یا کامنت گذاری استفاده شده)

```rust
fn main() {
    // In general, the `{}` will be automatically replaced with any
    // arguments. These will be stringified.
    println!("{} days", 31);

    // Without a suffix, 31 becomes an i32. You can change what type 31 is
    // by providing a suffix. The number 31i64 for example has the type i64.

    // There are various optional patterns this works with. Positional
    // arguments can be used.
    println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");

    // As can named arguments.
    println!("{subject} {verb} {object}",
             object="the lazy dog",
             subject="the quick brown fox",
             verb="jumps over");

    // Special formatting can be specified after a `:`.
    println!("{} of {:b} people know binary, the other half doesn't", 1, 2);

    // You can right-align text with a specified width. This will output
    // "     1". 5 white spaces and a "1".
    println!("{number:>width$}", number=1, width=6);

    // You can pad numbers with extra zeroes. This will output "000001".
    println!("{number:>0width$}", number=1, width=6);
}
```

به خروجی کد بالا هم در زیر توجه کنید

```
31 days
Alice, this is Bob. Bob, this is Alice
the quick brown fox jumps over the lazy dog
1 of 10 people know binary, the other half doesn't
     1
000001
```

حالا بیاید مو به مو کد بالا رو بررسی کنیم.

در کد اول عدد `31` با علامت `{}` فرمت شده و خروجی بالا رو تولید کرده.

در کد دوم دو استرینگ یا رشته رو داریم که `Alice` در اندیس صفرم قرار داره و `Bob` در اندیس اول قرار داره شاید بپرسید چرا از صفر شروع شده جواب بسیار سادس **کامپیوتر ها** از صفر شروع به شمردن میکنن و ما با توجه به شماره اندیس آن ها فرمت را انجام دادیم.

در کد سوم با توجه به اسم **آرگومنت** هایی که داریم فرمت انجام شده و مقدارشون فرمت شده، توجه کنید که **نوع** هر سه یکی هست.

در کد چهارم هم ما با استفاده از علامت `:` فرمت خاصی رو انجام دادیم.

در کد پنجم هم میتونیم به یک صورت دیگه بیان کنیم؛ `width` در زبان راست برای ما میاد عرضی رو میسازه و این عرض ما دارای عدد `6` هست و گفتیم شیش تا عرض بساز اما با هیچ چیزی این عرض رو پر نکن و بعد میاد برای ما عدد `1` رو چاپ میکنه و در نهایت پنج تا فاصله میفته با عدد یک.

در کد ششم هم مانند کد پنجم عمل کردیم با این تفاوت که گفتیم بیا عرض ایجاد شده رو با عدد `0` پر کن.

### تمرین

حالا بیاید از تمام چیزایی که یادگرفتیم یک تمرین ساده ای رو انجام بدیم؛ به کد زیر توجه کنید

```rust
fn main() {
        // create a variable with f64 type and use static type
        let variable: f64 = 3.14000000;

        /* format and print the variable */
        println!("variable: {}", variable);
}
```

به خروجی کد بالا در زیر هم توجه کنید

```
variable: 3.14
```

حالا بیاید برای خودتون با چیزایی که یادگرفتید کد بالا رو تحلیل کنید توجه کنید که صفر های اضافه بعد از `4` چاپ نمیشن.
امیدوارم از این مقاله هم لذت کافی رو برده باشید :)
