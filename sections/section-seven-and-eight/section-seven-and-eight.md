توی یکی دیگه از مقالات راست میخوایم دو بخش هفت و هشت رو با هم بخوونیم.

![مقاله ی آموزشی زبان راست در پارس کلیک](https://images.pexels.com/photos/735911/pexels-photo-735911.jpeg?auto=compress&cs=tinysrgb&dpr=1&w=500)

# بخش هفت

توی بخش هفت میخوایم با مفهوم `ownership` آشنا بشیم و قوانین های این موضوع رو بررسی کنیم و مثال هایی رو کار کنیم.

##  این مفهوم چیست و چه قوانینی دارد

زبان راست مثل بعضی از زبان های دیگه دارای ویژگی `ownership` هست.

اما سوالی که پیش میاد اینه که `ownership` دقیقا توی راست چیه ؟

> منظور از اسکوپ {} هست

سیستم `ownership` توی راست به این صورت هست که تمام مقادیری که توی راست تعریف میشه باید یه صاحب داشته باشن توجه کنید که این صاحب باید تک و بی نظیر باشه یا به قولی یونیک باشه و چیزی مثل اون نباشه و باید گفت که مقادیری که توی یه اسکوپ مورد نظر هستن همان اسکوپی هست که صاحب توی آن اسکوپ هست.
مقادیر موجود توی راست میتونن پاس داده بشن به عنوان یک مقدار تغییرناپذیر با استفاده از `&T`ولی شما میتونید مقادیر موجود توی راست رو پاس بدید به صورت تغییرپذیر در صورت نیاز به  `نغییر` و با استفاده از `&mut T` این کار انجام میشه یا حتی میتونید از رفرنس استفاده نکنید و به این صورت `T` این کارو انجام بدید، راست همیشه میتونه چند تا رفرنس تغییرناپذیر رو پاس بده یا چند تغییرپذیر رو، سیستم `ownership` در کامپایلر راست یک اجبار هست و اختیاری نیست و حتی قوانین `ownership` در زمان کامپایل چک میشه و حتی چک میکنه که تمام رفرنس ها مشکلی نداشته باشن که بعدا برای حل اینجور مشکلات هم راه حلی هست که `لایف تایم` نام داره.

ممکنه با خووندن توضیحات بالا کمی گیج شده باشید یا ممکنه گیج نشده باشید اما حالا بیاید قوانین `ownership` رو بررسی کنیم و بعد انقدر مثال میزنیم که مسائل جا میوفته.

قوانین `ownership` در راست در کل سه تا هست سعی کنید این قوانین را حفظ کنید که در کار با راست خیلی به شما کمک میکنه و میتونیم بگیم که یک اجباره وگرنه به مشکل میخورید با راست

- هر مقداری که توی راست تعریف میشه یه متغییر داره که صاحب یا owner نام داره
- هر مقداری در راست فقط یه صاحب میتونه داشته باشه
- زمانی که صاحبی که تعریف شده بود توی اسکوپ مشخصی از اون اسکوپ زد بیرون مقدار و صاحب کلا پاک میشه از حافظه

حالا بریم چند تا مثال حل کنیم تا مسائل بهتر جا بیوفته.

به مثال زیر توجه کنید

```rust
fn main() {
    {
        let x = String::from("Hello World"); // از اینجا به بعد متغییر x در دسترس هست 
        println!("{}", x); // هرکاری که میخواید رو با متغیر x انجام میدید
    } // اینجا اسکوپی که ایجاد کرده بودیم تموم میشه و متغیر x از بین میره و دیگه در دسترس نیست
}
```

خروجی کد بالا

```
Hello World
```

در کد بالا یه مقداری رو توی راست تعریف کردیم در واقع متغیری رو ساختیم که مقداری رو داشت و صاحب اون مقدار `x` بود و بعد کار هایی که میخواستیم رو با `x` انجام دادیم و بعد از تموم شدن اسکوپ ایجاد شده دیگه `x` از بین میره و دیگه در دسترس نیست.

شاید از خوپتون بپرسید از کجا معلوم از بین میره ؟
خب جواب سادس میام امتحان میکنیم.

به کد زیر توجه کنید

```rust
fn main() {
    {
        let x = String::from("Hello World");
    }
    println!("{}", x); // Error
}
```

خروجی کد بالا

```
error[E0425]: cannot find value `x` in this scope
println!("{}", x);
               ^ not found in this scop
```

دیدید که اثبات کردیم که قوانین `ownership` در راست به صورت اجباری اجرا میشن و یک ویژگی اختیاری نیست.

حالا بیاید یه مثال دیگه بزنیم، به مثال زیر توجه کنید

```rust
fn main() {
    let string1 = String::from("Hello World from sami2020pro");
    let string2 = string1;

    println!("{}", string2);
}
```

به خروجی کد بالا توجه باشید

```
Hello World from sami2020pro
```

اگه توجه کنید میبینید که `string1` رو کپی کردیم توی `string2` و اونو چاپ کردیم اما باید بگم که اشتباه فکر میکنید و حالا از خودتون میپرسید چرا ؟

در واقع ما `string1` رو کپی نکردیم و در اصل انتقال دادیم به `string2` و بعد از انتقال دیگه `string1` وجود نداره و دیگه هم صاحب اون رشته نیست و در اصل `string2` صاحب اون استرینگ شده.

شاید بگید این موضوع توی زبان پایتون وجود نداره !
بله درسته این موضوع توی پایتون وجود نداره ولی راست بسیار متفاوت از پایتون هست.

برای اثبات به مثال زیر توجه کنید

```rust
fn main() {
    let string1 = String::from("Hello World from sami2020pro");
    let string2 = string1;

    println!("{}", string2);
    println!("{}", string1); // Error
}
```

خروجی کد بالا

```
borrow of moved value: `string1`
...
```

میبینید که ما `string1` رو انتقال دادیم یا همون `move` کردیم و دیگه نیست.

> البته این یه توضیح خیلی ساده هست و میتونید توضیحات بیشتری رو از مستندات اضلی پیدا کنید



# بخش هشت

توی بخش هشت میخوایم مفاهیم `references` و `borrowing` رو توی راست یادبگیریم.

در بخش قبلی یعنی بخش هفت پیش نیاز این بخش رو یادگرفتیم و الان مشکلی برای این بخش نداریم اگه هنوز بخش قبل رو متوجه نشدید پیشنهاد میکنم دوباره بخوونید.